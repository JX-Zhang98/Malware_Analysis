# Lab 5-1
Analyze the malware found in the file Lab05-01.dll using only IDA Pro. The
goal of this lab is to give you hands-on experience with IDA Pro. If you¡¯ve
already worked with IDA Pro, you may choose to ignore these questions and
focus on reverse-engineering the malware.
Questions

1. **What is the address of DllMain?**

   ![](pic/main.png)

   在函数列表中搜索main，可以找到main函数地址为0x1000d02e

2. **Use the Imports window to browse to gethostbyname. Where is the import located?**

   ![](pic/import.png)

   在import窗口中搜索*gethostbyname*， 直接定位到该函数，可以确定此导入函数位于WS2_32.dll中。

3. **How many functions call gethostbyname?**

   ![](pic/xref.png)

   在import窗口双击gethostbyname函数进入函数声明，按x键显示该函数的交叉引用，可以得到共有18处对此函数的引用。

   但是在18处引用中存在很多同一函数的多次引用，排除重复后剩余5个函数中对此函数进行了调用。

4. **Focusing on the call to gethostbyname located at 0x10001757, can you figure out which DNS request will be made?**

   ![](pic/argv.png)

   在函数声明中可以确定，此函数的参数为一个字符串指针。上图选中部分为传参阶段。

   首先将偏移0x10019040处的值赋值给eax，然后eax+13，最后将eax作为参数压栈。在以上过程中，等效于压栈的参数实际为[0x10019040]+13。点击off_10019040进入查看数据，该部分位于.data段，即变量定义时进行了初始化的变量，可读写。

   ![](pic/9040.png)

   进入Hex View窗口查看0x10019040位置的数值为0x10019194。

   ![](pic/addr.png)

   点击字符串进入字符串所在位置，真正传入的参数应该是0x100191a1，即进行dns查询的域名是pics.praticalmalwareanalysis.com。

5. **How many local variables has IDA Pro recognized for the subroutine at 0x10001656?**

   ![](pic/local.png)

   使用F5插件生成伪代码，发现有大量的寄存器变量，分布在栈上的局部变量有24个

6. **How many parameters has IDA Pro recognized for the subroutine at 0x10001656?**

   ![](pic/arg1656.png)

   经过ida识别，sub_10001656函数有一个参数

7. **Use the Strings window to locate the string \cmd.exe /c in the disassembly.Where is it located?**

   ![](pic/cmd.png)

   在strings 窗口进行搜索，可以直接定位字符串，发现其地址位于0x10095b34

8. **What is happening in the area of code that references \cmd.exe /c?**

   点击字符串进入后，ida给出交叉引用提示：*DATA XREF: sub_1000FF58+278↑*， 程序在sub_1000ff58+278处调用了该字符串。

   ![](pic/1dc.png)

   在该处，将字符串指针压栈之后，跳转到0x100101dc位置，再将局部变量commandLine压栈，然后调用strcat函数，所以是执行了<code>strcat(commandLine, "\cmd.exe /c")</code>命令

9. **In he same area, at 0x100101C8, it looks like dword_1008E5C4 is a global variable that helps decide which path to take. How does the malware set dword_1008E5C4? (Hint: Use dword_1008E5C4¡¯s cross-references.)**

   ![](pic/e5c4.png)

   通过对变量DWORD_1008e5c4的交叉引用查询，可以看到，三处引用中，后两次都是在cmp指令中，是作为分值判断的依据，只有在sub_10001656+22处的mov指令中改变了变量的值

   > .text:10001673                 call    sub_10003695
   > .text:10001678                 mov     dword_1008E5C4, eax

   在该处， 使用sub_10003695函数的返回值为dword_1008E5C4赋值

10. **A few hundred lines into the subroutine at 0x1000FF58, a series of comparisons use memcmp to compare strings. What happens if the string comparison to robotwork is successful (when memcmp returns 0)?**

    ![](pic/robotwork.png)

    调用memcmp函数后，检测返回值eax，如果eax为0，则ZF寄存器置1，然后调用sub_100052A2(s)函数

11. **What does the export PSLIST do?**

    该函数获取系统版本信息，然后将str字符串通过网络发送

12. **Use the graph mode to graph the cross-references from sub_10004E79. Which API functions could be called by entering this function? Based on the API functions alone, what could you rename this function?**

    ![](pic/4e79.png)

    生成cross-references from调用图如上

    通过这个函数可以调用GetSystemDefaultLangID、sprintf、strlen、malloc、free、send和__imp_strlen这些API会被调用。

    可以重命名为send_LangID

13. **How many Windows API functions does DllMain call directly? How many at a depth of 2?**

    

    ![](pic/chart.png)

    在user xrefs chart中设置递归深度为1，可以直接查看DllMain函数第一层直接调用的函数

    ![](pic/level.png)

    可以看到直接调用了strncpy、_strnicmp、CreateThread和strlen四个Windows API

    设置递归深度为2，查看第二层调用的API有gethostbyname、WinExec、Sleep等33个Windows API

14. **At 0x10001358, there is a call to Sleep (an API function that takes one parameter containing the number of milliseconds to sleep). Looking backward through the code, how long will the program sleep if this code executes?**

    ![](pic/sleep.png)

    此处代码取偏移0x10019020的值作为字符串指针，将此字符串向后偏移13字节的字符串即“30”作为atoi的参数，然后将atoi的返回值乘1000，再压入栈中调用sleep，所以程序将sleep的时间是30秒。

15. **At 0x10001701 is a call to socket. What are the three parameters?**

    ![](pic/socket.png)

    使用栈传参时，逆序传参，所以如栈顺序为参数的反顺序，即调用为：socket(2, 1, 6)

16. **Using the MSDN page for socket and the named symbolic constants functionality in IDA Pro, can you make the parameters more meaningful? What are the parameters after you apply changes?**

    三个参数分别是(af， type， protocol)

    af = 2 : 表示使用ipv4网络

    type = 1 ： 表示传输的数据类型是SOCK_STREAM

    protocol = 6 : 表示使用tcp进行传输。

    更改后参数应该是socket(**AF_INET**, **SOCK_STREAM**, **IPPROTO_TCP**)

17. **Search for usage of the in instruction (opcode 0xED). This instruction is used with a magic string VMXh to perform VMware detection. Is that in use in this malware? Using the cross-references to the function that executes the in instruction, is there further evidence of VMware detection?**

    in指令用于从端口读入信息到寄存器中。

    ![](pic/vmxh.png)

    使用search sequence byte功能搜索0xed，能够找到此病毒程序最后那个确实存在in指令，将其前面几个指令中的十六进制数转化成字符串之后，出现了VMXh字符串。

    ![](pic/6196.png)

    使用xrefs功能查看此函数，发现在installRT、InstallSA、InstallSB函数中均调用了此函数。

    经过查看，三个函数结构非常相似，均含有以下部分：

    ![](pic/vmm.png)

    在调用了sub_10006196之后，根据字符串推断，sub_10006196函数返回了检测虚拟机的结果，当发现存在虚拟机的时候便取消安装，也说明此病毒中存在对抗虚拟机分析的行为

18. **Jump your cursor to 0x1001D988. What do you find?**

    0x1001d988位于.data段，是一段二进制数据

    ![](pic/data.png)

    按c之后发现该数据被发编译成为了一段汇编代码。说明该病毒以数据的形式在.data段存储了一段恶意代码，以规避检查，当然这使得程序在运行期间需要给予数据段的执行权限，可以执行任意shellcode，极大地降低了程序被攻破的难度，当然也增加了分析的复杂度，需要进行动态调试方能确定调用此地址执行的最终代码。

19. **If you have the IDA Python plug-in installed (included with the commercial version of IDA Pro), run Lab05-01.py, an IDA Pro Python script provided with the malware for this book. (Make sure the cursor is at 0x1001D988.) What happens after you run the script?**

    ![](pic/decode.png)

    使用ida python执行了示例代码后，0x1001d988处的数据都发生了变化，变成了一串可读的字符串，也说明上一步中强行对数据进行的反编译是错误的方向。

20. **With the cursor in the same location, how do you turn this data into a single ASCII string?**

    对于成列的单个字符数据，按A键，转化成字符串，19题的截图中已经将字符data转成了字符串

21. **Open the script with a text editor. How does it work?**

    ```python
    sea = ScreenEA()
    
    for i in range(0x00,0x50):
            b = Byte(sea+i)
            decoded_byte = b ^ 0x55
            PatchByte(sea+i,decoded_byte)
    
    ```

    ScreenEA()获取当前光标所在位置，然后从当前位置开始向后0x50个字节，获取当前字节数据b，然后patch成为b^0x55,最终转换成为可读的字符串

    

    